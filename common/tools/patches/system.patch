diff --git a/system/core/init/builtins.c b/system/core/init/builtins.c
index c192551..ae00c98 100644
--- a/system/core/init/builtins.c
+++ b/system/core/init/builtins.c
@@ -502,6 +502,15 @@ int do_mount_all(int nargs, char **args)
     int status;
     const char *prop;
     struct fstab *fstab;
+//
+    FILE *check_dart_file;
+    ssize_t len;
+    size_t alloc_len = 0;
+    char *line = NULL;
+    char *line1 = NULL;
+    int dart=0;
+    static char *dart_fstab = "/fstab_emmc_dart.freescale";
+
 
     if (nargs != 2) {
         return -1;
@@ -530,7 +539,29 @@ int do_mount_all(int nargs, char **args)
     } else if (pid == 0) {
         /* child, call fs_mgr_mount_all() */
         klog_set_level(6);  /* So we can see what fs_mgr_mount_all() does */
-        fstab = fs_mgr_read_fstab(args[1]);
+
+
+	check_dart_file = fopen("/sys/devices/soc0/machine", "r");
+	getline(&line, &alloc_len, check_dart_file);
+	fclose(check_dart_file);
+	char *pch = strstr(line, "VAR-DART");
+	if (pch){
+		check_dart_file = fopen("/fstab.freescale", "r");
+		getline(&line1, &alloc_len, check_dart_file);
+		fclose(check_dart_file);
+		char *pch1 = strstr(line1, "eMMC");
+		if (pch1) dart=1;
+	}
+
+	/* The name of the fstab file is last, after the option */
+	if (dart){
+		ERROR("FSTAB: DART found switching to: %s \n", dart_fstab);
+	        fstab = fs_mgr_read_fstab(dart_fstab);
+	} else {
+		ERROR("FSTAB: using file: %s \n", args[1]);
+	        fstab = fs_mgr_read_fstab(args[1]);
+	}
+
         child_ret = fs_mgr_mount_all(fstab);
         fs_mgr_free_fstab(fstab);
         if (child_ret == -1) {
diff --git a/system/core/init/devices.c b/system/core/init/devices.c
index 1012fee..4539ff3 100644
--- a/system/core/init/devices.c
+++ b/system/core/init/devices.c
@@ -66,6 +66,8 @@ struct uevent {
     const char *firmware;
     const char *partition_name;
     const char *device_name;
+    const char *country;
+    const char *modalias;
     int partition_num;
     int major;
     int minor;
@@ -391,6 +393,8 @@ static void parse_event(const char *msg, struct uevent *uevent)
     uevent->path = "";
     uevent->subsystem = "";
     uevent->firmware = "";
+    uevent->country = "";
+    uevent->modalias = "";
     uevent->major = -1;
     uevent->minor = -1;
     uevent->partition_name = NULL;
@@ -426,6 +430,12 @@ static void parse_event(const char *msg, struct uevent *uevent)
         } else if(!strncmp(msg, "DEVNAME=", 8)) {
             msg += 8;
             uevent->device_name = msg;
+        } else if (!strncmp(msg, "COUNTRY=", 8)) {
+            msg += 8;
+            uevent->country = msg;
+        } else if (!strncmp(msg, "MODALIAS=", 9)) {
+            msg += 9;
+            uevent->modalias = msg;
         }
 
         /* advance to after the next \0 */
@@ -433,9 +443,10 @@ static void parse_event(const char *msg, struct uevent *uevent)
             ;
     }
 
-    log_event_print("event { '%s', '%s', '%s', '%s', %d, %d }\n",
+    log_event_print("event { '%s', '%s', '%s', '%s', %d, %d, '%s', '%s' }\n",
                     uevent->action, uevent->path, uevent->subsystem,
-                    uevent->firmware, uevent->major, uevent->minor);
+                    uevent->firmware, uevent->major, uevent->minor,
+                    uevent->country, uevent->modalias);
 }
 
 static char **get_character_device_symlinks(struct uevent *uevent)
@@ -923,6 +934,38 @@ root_free_out:
     free(root);
 }
 
+static void handle_crda_event(struct uevent *uevent)
+{
+    int status;
+    int ret;
+    pid_t pid;
+    char country_env[128];
+    char *argv[] = { "/system/bin/crda", NULL };
+    char *envp[] = { country_env, NULL };
+
+    if(strcmp(uevent->subsystem, "platform"))
+        return;
+
+    if(strcmp(uevent->action, "change"))
+        return;
+
+    if(strcmp(uevent->modalias, "platform:regulatory"))
+        return;
+
+    log_event_print("executing CRDA country=%s\n", uevent->country);
+    sprintf(country_env, "COUNTRY=%s", uevent->country);
+
+    pid = fork();
+    if (!pid) {
+        if (-1 == execve(argv[0], argv, envp))
+            exit(1);
+    } else if (pid != -1) {
+        do {
+            ret = waitpid(pid, &status, 0);
+        } while (ret == -1 && errno == EINTR);
+    }
+}
+
 static void handle_firmware_event(struct uevent *uevent)
 {
     pid_t pid;
@@ -968,6 +1011,7 @@ void handle_device_fd()
 
         handle_device_event(&uevent);
         handle_firmware_event(&uevent);
+        handle_crda_event(&uevent);
     }
 }
 
diff --git a/system/core/init/init.c b/system/core/init/init.c
index b472d5b..81a5990 100644
--- a/system/core/init/init.c
+++ b/system/core/init/init.c
@@ -673,6 +673,7 @@ static int keychord_init_action(int nargs, char **args)
 static int console_init_action(int nargs, char **args)
 {
     int fd;
+    char tmp[PROP_VALUE_MAX];
 
     if (console[0]) {
         snprintf(console_name, sizeof(console_name), "/dev/%s", console);
@@ -683,6 +684,11 @@ static int console_init_action(int nargs, char **args)
         have_console = 1;
     close(fd);
 
+    if ((property_get("ro.boot.write_on_console", tmp) != 0) && (strcmp(tmp, "disabled") == 0)) {
+        /* just disable following (ugly) write */
+        return 0;
+    }
+
     fd = open("/dev/tty0", O_WRONLY);
     if (fd >= 0) {
         const char *msg;
diff --git a/system/netd/server/Android.mk b/system/netd/server/Android.mk
index 55aa87c..e2e06c3 100644
--- a/system/netd/server/Android.mk
+++ b/system/netd/server/Android.mk
@@ -28,6 +28,10 @@ LOCAL_CLANG := true
 LOCAL_CPPFLAGS := -std=c++11 -Wall -Werror
 LOCAL_MODULE := netd
 
+ifdef USES_TI_MAC80211
+LOCAL_CPPFLAGS += -DSINGLE_WIFI_FW
+endif
+
 LOCAL_SHARED_LIBRARIES := \
         libcrypto \
         libcutils \
diff --git a/system/netd/server/SoftapController.cpp b/system/netd/server/SoftapController.cpp
index adbd143..2d43d99 100644
--- a/system/netd/server/SoftapController.cpp
+++ b/system/netd/server/SoftapController.cpp
@@ -90,10 +90,14 @@ int SoftapController::startSoftap() {
            ret = execl(HOSTAPD_BIN_FILE_BCM, HOSTAPD_BIN_FILE,
                        "-e", WIFI_ENTROPY_FILE,
                        HOSTAPD_CONF_FILE, (char *) NULL);
-
-        } else
+        } else {
             ALOGE("no specific driver vendor");
-        ALOGE("execl failed (%s)", strerror(errno));
+            ret = execl(HOSTAPD_BIN_FILE, HOSTAPD_BIN_FILE,
+                       "-e", WIFI_ENTROPY_FILE,
+                       HOSTAPD_CONF_FILE, (char *) NULL);
+        }
+        if (ret)
+            ALOGE("execl failed (%s)", strerror(errno));
         ALOGE("SoftAP failed to start");
         return ResponseCode::ServiceStartFailed;
     } else {
@@ -225,6 +229,10 @@ int SoftapController::fwReloadSoftap(int argc, char *argv[])
 {
     char *fwpath = NULL;
 
+#ifdef SINGLE_WIFI_FW
+    return ResponseCode::CommandOkay;
+#endif
+
     if (argc < 4) {
         ALOGE("SoftAP fwreload is missing arguments. Please use: softap <wlan iface> <AP|P2P|STA>");
         return ResponseCode::CommandSyntaxError;
