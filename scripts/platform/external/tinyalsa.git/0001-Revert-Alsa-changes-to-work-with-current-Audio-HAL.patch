From b7fb3391b965028324f4ad863ecb9cb78767e562 Mon Sep 17 00:00:00 2001
From: Harshesh Valera <harshesh.v@variscite.com>
Date: Tue, 19 Dec 2017 18:16:16 -0800
Subject: [PATCH] Revert Alsa changes to work with current Audio HAL

Change-Id: If2da3ee0b78a9333b5a0db87a2b24b81bccc9ade
Signed-off-by: Harshesh Valera <harshesh.v@variscite.com>
---
 Android.mk                   |   2 +-
 control.c                    | 274 +++++++++++++++++++++++++++++++++++++++++++
 include/tinyalsa/asoundlib.h |  48 ++++++++
 pcm.c                        | 153 +++++++++++++++++++++++-
 4 files changed, 470 insertions(+), 7 deletions(-)
 create mode 100644 control.c

diff --git a/Android.mk b/Android.mk
index 0c42e13..f2200ea 100644
--- a/Android.mk
+++ b/Android.mk
@@ -2,7 +2,7 @@ LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
 LOCAL_C_INCLUDES:= external/tinyalsa/include
-LOCAL_SRC_FILES:= mixer.c pcm.c
+LOCAL_SRC_FILES:= mixer.c pcm.c control.c
 LOCAL_MODULE := libtinyalsa
 LOCAL_SHARED_LIBRARIES:= libcutils libutils
 LOCAL_MODULE_TAGS := optional
diff --git a/control.c b/control.c
new file mode 100644
index 0000000..4a197b0
--- /dev/null
+++ b/control.c
@@ -0,0 +1,274 @@
+/* mixer.c
+**
+** Copyright 2011, The Android Open Source Project
+** Copyright (C) 2012 Freescale Semiconductor, Inc.
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**     * Redistributions of source code must retain the above copyright
+**       notice, this list of conditions and the following disclaimer.
+**     * Redistributions in binary form must reproduce the above copyright
+**       notice, this list of conditions and the following disclaimer in the
+**       documentation and/or other materials provided with the distribution.
+**     * Neither the name of The Android Open Source Project nor the names of
+**       its contributors may be used to endorse or promote products derived
+**       from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY The Android Open Source Project ``AS IS'' AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED. IN NO EVENT SHALL The Android Open Source Project BE LIABLE
+** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+** DAMAGE.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+
+#include <linux/ioctl.h>
+#define __force
+#define __bitwise
+#define __user
+#include <sound/asound.h>
+
+#include <tinyalsa/asoundlib.h>
+
+struct ctl_pcm_info {
+    struct snd_pcm_info      *info;
+    struct ctl_pcm_info      *next;
+};
+
+
+struct control {
+    int fd;
+    struct snd_ctl_card_info *card_info;
+    struct ctl_pcm_info      *pcm_info_p;
+    unsigned int count_p;
+    struct ctl_pcm_info      *pcm_info_c;
+    unsigned int count_c;
+};
+
+struct control *control_open(unsigned int card)
+{
+    struct snd_ctl_card_info tmp;
+    struct control *control = NULL;
+    unsigned int n, m;
+    int fd;
+    char fn[256];
+    int device = -1;
+    struct ctl_pcm_info      *current;
+
+    snprintf(fn, sizeof(fn), "/dev/snd/controlC%u", card);
+    fd = open(fn, O_RDWR);
+    if (fd < 0)
+        return 0;
+
+    control = calloc(1, sizeof(*control));
+    if (!control)
+        goto fail;
+
+    control->count_p   = 0;
+    control->count_c   = 0;
+    control->fd        = fd;
+    control->card_info = calloc(1, sizeof(struct snd_ctl_card_info));
+    if (!control->card_info)
+        goto fail;
+
+    if (ioctl(fd, SNDRV_CTL_IOCTL_CARD_INFO, control->card_info) < 0)
+        goto fail;
+
+    control->pcm_info_p = calloc(1, sizeof(struct ctl_pcm_info));
+    if (!control->pcm_info_p)
+        goto fail;
+
+    current = control->pcm_info_p;
+    device = -1;
+    while(1)
+    {
+        if (ioctl(fd, SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE, &device) < 0)
+            break;
+        if(device < 0)
+            break;
+
+        control->count_p           += 1;
+        current->info = calloc(1, sizeof(struct snd_pcm_info));
+        if (!current->info)
+            goto fail;
+
+        current->info->device       = device;
+        current->info->subdevice    = 0;
+        current->info->stream       = SNDRV_PCM_STREAM_PLAYBACK;
+
+        if (ioctl(fd, SNDRV_CTL_IOCTL_PCM_INFO, current->info) < 0)
+            break;
+
+        current->next = calloc(1, sizeof(struct ctl_pcm_info));
+        if (!current->next)
+            goto fail;
+        current = current->next;
+    }
+
+    control->pcm_info_c = calloc(1, sizeof(struct ctl_pcm_info));
+    if (!control->pcm_info_c)
+        goto fail;
+
+    current = control->pcm_info_c;
+    device = -1;
+    while(1)
+    {
+        if (ioctl(fd, SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE, &device) < 0)
+            break;
+        if(device < 0)
+            break;
+
+        control->count_c           += 1;
+        current->info = calloc(1, sizeof(struct snd_pcm_info));
+        if (!current->info)
+            goto fail;
+
+        current->info->device       = device;
+        current->info->subdevice    = 0;
+        current->info->stream       = SNDRV_PCM_STREAM_CAPTURE;
+
+        if (ioctl(fd, SNDRV_CTL_IOCTL_PCM_INFO, current->info) < 0)
+            break;
+
+        current->next = calloc(1, sizeof(struct ctl_pcm_info));
+        if (!current->next)
+            goto fail;
+        current = current->next;
+    }
+    return control;
+
+fail:
+    if (control)
+        control_close(control);
+    else if (fd >= 0)
+        close(fd);
+    return 0;
+}
+
+void control_close(struct control *control)
+{
+    unsigned int n,m;
+    struct ctl_pcm_info      *current;
+    struct ctl_pcm_info      *p;
+
+    if (!control)
+        return;
+
+    if (control->fd >= 0)
+        close(control->fd);
+
+    if (control->card_info)
+        free(control->card_info);
+
+    current = control->pcm_info_p;
+    while(!current)
+    {
+        if(!current->info)
+            free(current->info);
+        p = current;
+        current = current->next;
+        free(p);
+    }
+
+    current = control->pcm_info_c;
+    while(!current)
+    {
+        if(!current->info)
+            free(current->info);
+        p = current;
+        current = current->next;
+        free(p);
+    }
+    free(control);
+}
+
+const char *control_card_info_get_id(struct control *control)
+{
+    if (!control)
+        return "";
+
+    return (const char *)control->card_info->id;
+}
+
+const char *control_card_info_get_driver(struct control *control)
+{
+    if (!control)
+        return "";
+
+    return (const char *)control->card_info->driver;
+}
+
+const char *control_card_info_get_name(struct control *control)
+{
+    if (!control)
+        return "";
+
+    return (const char *)control->card_info->name;
+}
+
+
+int control_pcm_next_device(struct control *control, int *device, int stream)
+{
+    struct ctl_pcm_info      *current;
+    if (!control)
+        return -EINVAL;
+
+    if(stream == SNDRV_PCM_STREAM_PLAYBACK)   current = control->pcm_info_p;
+    else                                      current = control->pcm_info_c;
+
+    while(!current->info)
+        if((int)current->info->device > *device)
+        {
+            *device = current->info->device;
+            return 0;
+        }
+    return -1;
+}
+
+
+const char *control_pcm_info_get_id(struct control *control, unsigned int device, int stream)
+{
+    struct ctl_pcm_info      *current;
+    if (!control)
+        return "";
+
+    if(stream == SNDRV_PCM_STREAM_PLAYBACK)   current = control->pcm_info_p;
+    else                                    current = control->pcm_info_c;
+
+    while(!current->info)
+        if(current->info->device == device)
+            return (const char *)current->info->id;
+
+    return "";
+}
+
+const char *control_pcm_info_get_name(struct control *control, unsigned int device, int stream)
+{
+    struct ctl_pcm_info      *current;
+    if (!control)
+        return "";
+
+    if(stream == SNDRV_PCM_STREAM_PLAYBACK)   current = control->pcm_info_p;
+    else                                    current = control->pcm_info_c;
+
+    while(!current->info)
+        if(current->info->device == device)
+            return (const char *)current->info->name;
+
+    return "";
+}
+
+
diff --git a/include/tinyalsa/asoundlib.h b/include/tinyalsa/asoundlib.h
index 233d901..fc2dc99 100644
--- a/include/tinyalsa/asoundlib.h
+++ b/include/tinyalsa/asoundlib.h
@@ -1,6 +1,7 @@
 /* asoundlib.h
 **
 ** Copyright 2011, The Android Open Source Project
+** Copyright (C) 2012 Freescale Semiconductor, Inc.
 **
 ** Redistribution and use in source and binary forms, with or without
 ** modification, are permitted provided that the following conditions are met:
@@ -68,6 +69,27 @@ struct pcm;
 #define	PCM_STATE_SUSPENDED	7
 #define	PCM_STATE_DISCONNECTED	8
 
+#define PCM_HW_PARAM_ACCESS 0
+#define PCM_HW_PARAM_FORMAT 1
+#define PCM_HW_PARAM_SUBFORMAT 2
+#define PCM_HW_PARAM_FIRST_MASK PCM_HW_PARAM_ACCESS
+#define PCM_HW_PARAM_LAST_MASK PCM_HW_PARAM_SUBFORMAT
+#define PCM_HW_PARAM_SAMPLE_BITS 8
+#define PCM_HW_PARAM_FRAME_BITS 9
+#define PCM_HW_PARAM_CHANNELS 10
+#define PCM_HW_PARAM_RATE 11
+#define PCM_HW_PARAM_PERIOD_TIME 12
+#define PCM_HW_PARAM_PERIOD_SIZE 13
+#define PCM_HW_PARAM_PERIOD_BYTES 14
+#define PCM_HW_PARAM_PERIODS 15
+#define PCM_HW_PARAM_BUFFER_TIME 16
+#define PCM_HW_PARAM_BUFFER_SIZE 17
+#define PCM_HW_PARAM_BUFFER_BYTES 18
+#define PCM_HW_PARAM_TICK_TIME 19
+#define PCM_HW_PARAM_FIRST_INTERVAL PCM_HW_PARAM_SAMPLE_BITS
+#define PCM_HW_PARAM_LAST_INTERVAL PCM_HW_PARAM_TICK_TIME
+#define PCM_HW_PARAMS_NORESAMPLE (1<<0)
+
 /* Bit formats */
 enum pcm_format {
     PCM_FORMAT_INVALID = -1,
@@ -254,8 +276,15 @@ int pcm_get_poll_fd(struct pcm *pcm);
  * Only accepted if opened with PCM_MMAP and PCM_NOIRQ flags
  */
 int pcm_set_avail_min(struct pcm *pcm, int avail_min);
+int pcm_drain(struct pcm *pcm);
+int pcm_state(struct pcm *pcm);
+int pcm_prepare(struct pcm *pcm);
+int pcm_get_near_param(unsigned int card, unsigned int device,
+                     unsigned int flags, int type, int *data);
 int pcm_get_time_of_status(struct pcm *pcm);
 int pcm_get_time_of_xrun(struct pcm *pcm);
+int pcm_check_param_mask(unsigned int card, unsigned int device,
+                     unsigned int flags, int type, int data);
 /*
  * MIXER API
  */
@@ -304,6 +333,25 @@ int mixer_ctl_set_enum_by_string(struct mixer_ctl *ctl, const char *string);
 int mixer_ctl_get_range_min(struct mixer_ctl *ctl);
 int mixer_ctl_get_range_max(struct mixer_ctl *ctl);
 
+
+/*
+ * CONTROL API
+ */
+struct control;
+
+/*Open and close a control */
+struct control *control_open(unsigned int card);
+void control_close(struct control *control);
+
+/* Get info about control controls */
+const char *control_card_info_get_id(struct control *control);
+const char *control_card_info_get_name(struct control *control);
+const char *control_card_info_get_driver(struct control *control);
+
+int control_pcm_next_device(struct control *control, int *device, int stream);
+const char *control_pcm_info_get_id(struct control *control, unsigned int device, int stream);
+const char *control_pcm_info_get_name(struct control *control, unsigned int device, int stream);
+
 #if defined(__cplusplus)
 }  /* extern "C" */
 #endif
diff --git a/pcm.c b/pcm.c
index d713775..69efbbf 100644
--- a/pcm.c
+++ b/pcm.c
@@ -1,7 +1,7 @@
 /* pcm.c
 **
 ** Copyright 2011, The Android Open Source Project
-** Copyright (C) 2012-2013 Freescale Semiconductor, Inc.
+** Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
 **
 ** Redistribution and use in source and binary forms, with or without
 ** modification, are permitted provided that the following conditions are met:
@@ -48,6 +48,7 @@
 #include <sound/asound.h>
 
 #include <tinyalsa/asoundlib.h>
+#include <android/log.h>
 
 #define PARAM_MAX SNDRV_PCM_HW_PARAM_LAST_INTERVAL
 
@@ -197,6 +198,7 @@ static unsigned int param_get_max(struct snd_pcm_hw_params *p, int n)
     return 0;
 }
 
+
 static void param_set_int(struct snd_pcm_hw_params *p, int n, unsigned int val)
 {
     if (param_is_interval(n)) {
@@ -217,6 +219,11 @@ static unsigned int param_get_int(struct snd_pcm_hw_params *p, int n)
     return 0;
 }
 
+static void param_set_rmask(struct snd_pcm_hw_params *p, int n)
+{
+    p->rmask |= 1 << n;
+}
+
 static void param_init(struct snd_pcm_hw_params *p)
 {
     int n;
@@ -308,6 +315,19 @@ static unsigned int pcm_format_to_alsa(enum pcm_format format)
     };
 }
 
+static unsigned int alsa_format_to_pcm(unsigned int format)
+{
+    switch (format) {
+    case SNDRV_PCM_FORMAT_S32_LE:
+        return PCM_FORMAT_S32_LE;
+    case SNDRV_PCM_FORMAT_S24_LE:
+        return PCM_FORMAT_S24_LE;
+    default:
+    case SNDRV_PCM_FORMAT_S16_LE:
+        return PCM_FORMAT_S16_LE;
+    };
+}
+
 unsigned int pcm_format_to_bits(enum pcm_format format)
 {
     switch (format) {
@@ -854,8 +874,10 @@ struct pcm *pcm_open(unsigned int card, unsigned int device,
     char fn[256];
     int rc;
 
+    if (!config)
+        return &bad_pcm;
     pcm = calloc(1, sizeof(struct pcm));
-    if (!pcm || !config)
+    if (!pcm)
         return &bad_pcm; /* TODO: could support default config here */
 
     pcm->config = *config;
@@ -1021,6 +1043,8 @@ int pcm_prepare(struct pcm *pcm)
     if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE) < 0)
         return oops(pcm, errno, "cannot prepare channel");
 
+    pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_APPL);
+
     pcm->prepared = 1;
     return 0;
 }
@@ -1233,15 +1257,15 @@ int pcm_mmap_transfer(struct pcm *pcm, const void *buffer, unsigned int bytes)
         /* get the available space for writing new frames */
         avail = pcm_avail_update(pcm);
         if (avail < 0) {
-            fprintf(stderr, "cannot determine available mmap frames");
+            oops(pcm, err, "cannot determine available mmap frames");
             return err;
         }
 
         /* start the audio if we reach the threshold */
-	    if (!pcm->running &&
+        if (!pcm->running &&
             (pcm->buffer_size - avail) >= pcm->config.start_threshold) {
             if (pcm_start(pcm) < 0) {
-               fprintf(stderr, "start error: hw 0x%x app 0x%x avail 0x%x\n",
+               oops(pcm, -errno, "start error: hw 0x%x app 0x%x avail 0x%x\n",
                     (unsigned int)pcm->mmap_status->hw_ptr,
                     (unsigned int)pcm->mmap_control->appl_ptr,
                     avail);
@@ -1292,7 +1316,7 @@ int pcm_mmap_transfer(struct pcm *pcm, const void *buffer, unsigned int bytes)
         /* copy frames from buffer */
         frames = pcm_mmap_transfer_areas(pcm, (void *)buffer, offset, frames);
         if (frames < 0) {
-            fprintf(stderr, "write error: hw 0x%x app 0x%x avail 0x%x\n",
+            oops(pcm, frames, "write error: hw 0x%x app 0x%x avail 0x%x\n",
                     (unsigned int)pcm->mmap_status->hw_ptr,
                     (unsigned int)pcm->mmap_control->appl_ptr,
                     avail);
@@ -1336,3 +1360,120 @@ int pcm_ioctl(struct pcm *pcm, int request, ...)
 
     return ioctl(pcm->fd, request, arg);
 }
+
+int pcm_drain(struct pcm *pcm)
+{
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DRAIN) < 0)
+        return oops(pcm, errno, "drain failed");
+
+    return 0;
+}
+
+int pcm_get_near_param(unsigned int card, unsigned int device,
+                     unsigned int flags, int type, int *data)
+{
+    struct pcm *pcm;
+    struct snd_pcm_hw_params params;
+    char fn[256];
+    int ret = 0;
+    int min = 0, max = 0;
+    int mask = 0;
+    int request_data = *data;
+    *data = 0;
+
+    if(param_is_mask(type)) return -1;
+
+    pcm = calloc(1, sizeof(struct pcm));
+    if (!pcm)
+        return -1;
+
+    snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
+             flags & PCM_IN ? 'c' : 'p');
+
+    pcm->flags = flags;
+    pcm->fd = open(fn, O_RDWR);
+    if (pcm->fd < 0) {
+        oops(pcm, errno, "cannot open device '%s'", fn);
+        ret = -1;
+        goto fail;
+    }
+
+    param_init(&params);
+    param_set_min(&params, type, request_data);
+    param_set_rmask(&params, type);
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_REFINE, &params)) {
+        oops(pcm, errno, "cannot set hw params rate min");
+    } else
+        min = param_get_min(&params, type);
+
+    param_init(&params);
+    param_set_max(&params, type, request_data);
+    param_set_rmask(&params, type);
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_REFINE, &params)) {
+        oops(pcm, errno, "cannot set hw params rate max");
+    }
+    else
+        max = param_get_max(&params, type);
+
+    if(min > 0)       *data = min;
+    else if(max > 0)  *data = max;
+    else              *data = 0;
+
+fail_close:
+    close(pcm->fd);
+    pcm->fd = -1;
+fail:
+    free(pcm);
+    return ret;
+}
+
+int pcm_check_param_mask(unsigned int card, unsigned int device,
+                     unsigned int flags, int type, int data)
+{
+    struct pcm *pcm;
+    struct snd_pcm_hw_params params;
+    char fn[256];
+    int ret = 0;
+    int min = 0, max = 0;
+    int mask = 0;
+    int request_data = data;
+
+    if (param_is_interval(type)) return 0;
+
+    pcm = calloc(1, sizeof(struct pcm));
+    if (!pcm)
+        return 0;
+
+    snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
+             flags & PCM_IN ? 'c' : 'p');
+
+    pcm->flags = flags;
+    pcm->fd = open(fn, O_RDWR);
+    if (pcm->fd < 0) {
+        oops(pcm, errno, "cannot open device '%s'", fn);
+        ret = 0;
+        goto fail;
+    }
+
+    param_init(&params);
+    if (type == PCM_HW_PARAM_FORMAT)
+        param_set_mask(&params, type, pcm_format_to_alsa(request_data));
+    else
+        param_set_mask(&params, type, request_data);
+    param_set_rmask(&params, type);
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_REFINE, &params) == 0) {
+        oops(pcm, errno, "cannot set hw params rate min");
+        ret = 1;
+    } else
+        ret = 0;
+
+fail_close:
+    close(pcm->fd);
+    pcm->fd = -1;
+fail:
+    free(pcm);
+    return ret;
+}
-- 
2.7.4

